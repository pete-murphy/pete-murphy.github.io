<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TIL</title>
  <link href="https://ptrfrncsmrph.github.io" rel="self" type="application/rss+xml" />
  <updated></updated>
  <author>
    <name>Pete</name>
  </author>
  <id>https://ptrfrncsmrph.github.io/</id>

  <entry>
    <title>Context vs Reader</title>
    <link href="https://ptrfrncsmrph.github.ioposts/context-vs-reader.html"/>
    <id>https://ptrfrncsmrph.github.ioposts/context-vs-reader.html</id>
    <updated>2022-01-21T00:00:00Z</updated>
    <category term="react"/>
    <category term="context"/>
    <category term="reader"/>
    <summary></summary>
    <content type="html"><![CDATA[<p>https://twitter.com/ryanflorence/status/1616121628706103297?s=20&amp;t=WSCLXkcCEXobbO3wLRYghw</p>
<blockquote>
<p>TypeScript is gonna bring back render props and kill hooks that
access React context.</p>
</blockquote>
<p>Could we do something like</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Component</span> state props <span class="ot">=</span> <span class="dt">ReaderT</span> (<span class="dt">Observable</span> state) <span class="dt">Effect</span> (props <span class="ot">-&gt;</span> <span class="dt">JSX</span>)</span></code></pre></div>]]></content>
  </entry>
  <entry>
    <title>Stateful for loops in Rust &amp;amp; Haskell</title>
    <link href="https://ptrfrncsmrph.github.ioposts/data-abstraction.html"/>
    <id>https://ptrfrncsmrph.github.ioposts/data-abstraction.html</id>
    <updated>2019-01-01T00:00:00Z</updated>
    <category term="slick"/>
    <category term="site"/>
    <category term="data abstraction"/>
    <category term="haskell"/>
    <category term="typescript"/>
    <summary>My first blog post using slick</summary>
    <content type="html"><![CDATA[<h1 id="stateful-for-loops-in-rust-haskell">Stateful <code>for</code>
loops in Rust &amp; Haskell</h1>
<p><strong>Advent of Code spoilers herein</strong></p>
<p>Let’s look at some <code>for</code> loops, shall we?!</p>
<p>Day five of this year’s Advent of Code this year provides a nice
occasion for doing some stateful computation. We were given:</p>
<ul>
<li>an initial state of some stacks of crates</li>
<li>a list of instructions for moving crates from one stack to
another</li>
</ul>
<p>In Haskell I ended up using the <code>State</code> <del>monad</del>
applicative functor, and I am compelled to write down why, because it
was not that long ago that <code>State</code> was completely baffling to
me.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">State</span> s a <span class="ot">=</span> <span class="dt">State</span> {<span class="ot"> runState ::</span> s <span class="ot">-&gt;</span> (a, s) }</span></code></pre></div>
<p>How does this really model “state”?—how can we use this the same way
that we use a global mutable reference in imperative-style programming.
Let’s get some imports out of the way first.</p>
<multicodeblock-tabs>
  <multicodeblock-tab role="heading" slot="tab">Haskell</multicodeblock-tab>
  <multicodeblock-panel role="region" slot="panel">
<div class="sourceCode" id="cb2"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.State</span> (modify)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Foldable</span> (for_)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span></span></code></pre></div>
  </multicodeblock-panel>
  <multicodeblock-tab role="heading" slot="tab">Rust</multicodeblock-tab>
  <multicodeblock-panel role="region" slot="panel">
<div class="sourceCode" id="cb3"><pre
class="sourceCode rust"><code class="sourceCode rust"></code></pre></div>
  </multicodeblock-panel>
  <multicodeblock-tab role="heading" slot="tab">Haskell</multicodeblock-tab>
  <multicodeblock-panel role="region" slot="panel">
<div class="sourceCode" id="cb4"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- interface, abstract type: A typeclass</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">ExampleClass</span> a <span class="kw">where</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  create ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  read1 ::</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></span></code></pre></div>
  </multicodeblock-panel>
  <multicodeblock-tab role="heading" slot="tab">F#</multicodeblock-tab>
  <multicodeblock-panel role="region" slot="panel">
<div class="sourceCode" id="cb5"><pre
class="sourceCode fsharp"><code class="sourceCode fsharp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> ExampleInterface&lt;&#39;a&gt; =</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">abstract</span> <span class="kw">member</span> create : <span class="dt">string</span> -&gt; &#39;a</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">abstract</span> <span class="kw">member</span> read   : &#39;a -&gt; <span class="dt">string</span></span></code></pre></div>
  </multicodeblock-panel>
</multicodeblock-tabs>
<h3 id="implementation">Implementation</h3>
<multicodeblock-tabs>
  <multicodeblock-tab role="heading" slot="tab">Swift</multicodeblock-tab>
  <multicodeblock-panel role="region" slot="panel">
<div class="sourceCode" id="cb6"><pre
class="sourceCode swift"><code class="sourceCode swift"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">// implementation: A struct (or a class)</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">struct</span> Example <span class="op">{</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="va">s</span><span class="op">:</span> string</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">public</span> <span class="kw">static</span> <span class="kw">func</span> <span class="fu">create</span><span class="op">(</span><span class="va">_</span> <span class="va">s</span><span class="op">:</span> <span class="dt">string</span><span class="op">)</span> -&gt; <span class="fu">Example</span> <span class="op">{</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> Example<span class="op">(</span>s<span class="op">:</span> s<span class="op">)</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">public</span> <span class="kw">func</span> <span class="fu">read</span><span class="op">()</span> -&gt; <span class="fu">String</span> <span class="op">{</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="kw">self</span><span class="op">.</span>s</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
  </multicodeblock-panel>
  <multicodeblock-tab role="heading" slot="tab">TypeScript</multicodeblock-tab>
  <multicodeblock-panel role="region" slot="panel">
<div class="sourceCode" id="cb7"><pre
class="sourceCode typescript"><code class="sourceCode typescript"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">// implementation: A function (for static members)</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="co">//                 A class (for instance ones)</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">createExample</span>(ctor<span class="op">:</span> ExampleConstructor<span class="op">,</span> s<span class="op">:</span> <span class="dt">string</span>)<span class="op">:</span> ExampleInterface {</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="kw">new</span> <span class="fu">ctor</span>(s)<span class="op">;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Example <span class="kw">implements</span> ExampleInterface {</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>  s<span class="op">:</span> <span class="dt">string</span><span class="op">;</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">constructor</span>(s<span class="op">:</span> <span class="dt">string</span>) {</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">s</span> <span class="op">=</span> s<span class="op">;</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">read</span>()<span class="op">:</span> <span class="dt">string</span> {</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">this</span><span class="op">.</span><span class="at">s</span><span class="op">;</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
  </multicodeblock-panel>
  <multicodeblock-tab role="heading" slot="tab">OCaml</multicodeblock-tab>
  <multicodeblock-panel role="region" slot="panel">
<div class="sourceCode" id="cb8"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- implementation: A typeclass instance</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ExampleClass</span> <span class="dt">String</span> <span class="kw">where</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  create <span class="ot">=</span> <span class="fu">id</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  read1 <span class="ot">=</span> <span class="fu">id</span></span></code></pre></div>
  </multicodeblock-panel>
  <multicodeblock-tab role="heading" slot="tab">F#</multicodeblock-tab>
  <multicodeblock-panel role="region" slot="panel">
<div class="sourceCode" id="cb9"><pre
class="sourceCode fsharp"><code class="sourceCode fsharp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> Example <span class="op">()</span> =</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    interface ExampleInterface&lt;<span class="dt">string</span>&gt; <span class="kw">with</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">member</span> _.create s = s</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">member</span> _.read s = s</span></code></pre></div>
  </multicodeblock-panel>
</multicodeblock-tabs>
<h3 id="client">Client</h3>
<multicodeblock-tabs>
  <multicodeblock-tab role="heading" slot="tab">Swift</multicodeblock-tab>
  <multicodeblock-panel role="region" slot="panel">
<div class="sourceCode" id="cb10"><pre
class="sourceCode swift"><code class="sourceCode swift"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="fu">client</span><span class="op">&lt;</span><span class="dt">E</span><span class="op">:</span> <span class="dt">ExampleInterface</span><span class="op">&gt;()</span> <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="va">ex</span> <span class="op">=</span> E<span class="op">.</span>create<span class="op">(</span><span class="st">&quot;hello&quot;</span><span class="op">);</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  println<span class="op">(</span>ex<span class="op">.</span>read<span class="op">());</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
  </multicodeblock-panel>
  <multicodeblock-tab role="heading" slot="tab">TypeScript</multicodeblock-tab>
  <multicodeblock-panel role="region" slot="panel">
<div class="sourceCode" id="cb11"><pre
class="sourceCode typescript"><code class="sourceCode typescript"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">// client</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="co">// it&#39;s a bit hard to write down a generic function for this in TypeScript</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="co">// because there are two separate interfaces</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> ex <span class="op">=</span> <span class="fu">createExample</span>(Example<span class="op">,</span> <span class="st">&quot;hello&quot;</span>)<span class="op">;</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(ex<span class="op">.</span><span class="fu">read</span>())<span class="op">;</span></span></code></pre></div>
  </multicodeblock-panel>
  <multicodeblock-tab role="heading" slot="tab">OCaml</multicodeblock-tab>
  <multicodeblock-panel role="region" slot="panel">
<div class="sourceCode" id="cb12"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* a client is a functor *)</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> Client(E: Example_intf) = <span class="kw">struct</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> ex = E.create <span class="st">&quot;hello&quot;</span> <span class="kw">in</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  printf <span class="st">&quot;%s</span><span class="ch">\n</span><span class="st">&quot;</span> (E.read ex)</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="co">(* we can make clients first-class with first-class modules *)</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> client (<span class="kw">module</span> E: Example_intf) =</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> ex = E.create <span class="st">&quot;hello&quot;</span> <span class="kw">in</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>  printf <span class="st">&quot;%s</span><span class="ch">\n</span><span class="st">&quot;</span> (E.read ex)</span></code></pre></div>
  </multicodeblock-panel>
  <multicodeblock-tab role="heading" slot="tab">Rust</multicodeblock-tab>
  <multicodeblock-panel role="region" slot="panel">
<div class="sourceCode" id="cb13"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> client<span class="op">&lt;</span>E<span class="op">:</span> Example<span class="op">&gt;</span>() <span class="op">{</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> ex <span class="op">=</span> <span class="pp">E::</span>create()<span class="op">;</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  <span class="pp">println!</span>(<span class="st">&quot;{:}&quot;</span><span class="op">,</span> ex<span class="op">.</span>read())<span class="op">;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
  </multicodeblock-panel>
  <multicodeblock-tab role="heading" slot="tab">Haskell</multicodeblock-tab>
  <multicodeblock-panel role="region" slot="panel">
<div class="sourceCode" id="cb14"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">client ::</span> <span class="dt">ExampleClass</span> e <span class="ot">=&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>client <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> ex <span class="ot">=</span> create <span class="st">&quot;hello&quot;</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> read1 ex</span></code></pre></div>
  </multicodeblock-panel>
  <multicodeblock-tab role="heading" slot="tab">F#</multicodeblock-tab>
  <multicodeblock-panel role="region" slot="panel">
<div class="sourceCode" id="cb15"><pre
class="sourceCode fsharp"><code class="sourceCode fsharp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> E = Example <span class="op">()</span> :&gt; ExampleInterface&lt;<span class="dt">string</span>&gt;</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> ex = E<span class="kw">.</span>create <span class="st">&quot;hello&quot;</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>E<span class="kw">.</span>read ex |&gt; printf <span class="st">&quot;%s</span><span class="sc">\n</span><span class="st">&quot;</span></span></code></pre></div>
  </multicodeblock-panel>
</multicodeblock-tabs>
<p>The surface syntax differs among programming languages, but through
them all, you can identify a <em>client</em> interacting with an
<em>implementation</em> through an <em>interface</em>. The extent to
which they achieve the ideal, from a semantics perspective, is something
we will study in this post. Studying the ideal equips the student with
the capacity for applying these techniques across all programming
languages rather than relearning what is truly the same each time a new
language is presented.</p>
<p>To <em>really</em> understand what an interface does it must be
equipped with laws. With sufficient laws, concrete implementations can
be swapped without clients observing changes, or dually, clients can be
written without implementations existing. “Sufficient laws” gives us
both obvious property-based tests and a state known as
<em>representation independence</em>, but this we will discuss in
another post.</p>
<p>We can concisely communicate these laws through the use of interfaces
that express algebraic structures. With enough practice, our whole
industry can instantly be aware of some structures’ associated laws just
through name recognition.</p>
<p>We can imagine a tower we can attempt to climb whenever working on
some piece of new code:</p>
<p>On the bottom, there is that which is is formed with the least
effort, buckets of plain code. We can add more order through interfaces.
Further refine it with laws. And finally, lighten the burden of needing
to constantly revisit laws through the identification of algebraic
structures.</p>
<p>Sometimes we’ll be unable to identify an algebraic structure, perhaps
we don’t want to put the time into discovering the laws, and we’re just
prototyping or writing glue so we don’t want to come up with interfaces.
But when necessary, the tower I’ve shown here gives us a strategy for
simplifying pieces of code.</p>
<p>In this post, we’ll focus only on the third layer, interfaces. Note
that we’ve already talked a bit about the top layer in earlier posts
starring <a href="/posts/semigroups-and-monoids">algebraic</a> <a
href="/posts/reducers-are-monoids">structures</a>. The second layer will
be discussed in a follow-up post.</p>
<h2 id="idealized-data-abstraction">Idealized Data Abstraction</h2>
<p>As stated earlier, understanding the concepts in your chosen language
is useful now, but understanding them from a formal perspective will
persist through your career. This post will show how these idealized
forms manifest in mainstream languages as a tool for better
internalizing these concepts.</p>
<p>To motivate the right way to think about abstract data types
(interfaces), I want to contrast it to working with parametric
polymorphism which you may know this as programming with “generic”s or
“template”s.</p>
<p>Consider a function that takes in a list of arbitrary elements, <span
class="math inline"><em>A</em></span>, and returns the length.</p>
<p>When implementing the body of such parametrically polymorphic
functions we’re constrained to not rely on the type of <span
class="math inline"><em>A</em></span>. In return, callers of our
function have the liberty to choose any <span
class="math inline"><em>A</em></span> — in our case they can pass a list
of <code>int</code>s a list of <code>string</code>s or a list of
<code>frog</code>s. This is also known as <em>universal
quantification</em> of our type variable, <span
class="math inline"><em>A</em></span>.</p>
<p>When defining such generic functions we’re defining a family of
functions: One for each choice of concrete type. This family is, in a
sense, an infinite product<a href="#fn1" class="footnote-ref"
id="fnref1" role="doc-noteref"><sup>1</sup></a> of all such
functions.</p>
<p>Consider an abstract data type representing an integer stack that is
never empty. What we’re describing is “some stacklike thing” that can
push and pop integers.</p>
<p>When implementing our functions we have the liberty to rely on the
concrete type. Essentially, the self is a parameter for some of these
functions. The self passing is implicit in many languages, but,
interestingly, very explicit in Rust. In contrast, users of our
interface, callers of create, push, and pop, are constrained to not be
able to rely on the concrete type of the stack.</p>
<p>When defining such abstract data types in a sense we’re defining a
family of constructors for data types: One for each choice of concrete
implementation as we can forget the details that make these
implementations unique. This family is, in a sense, an infinite sum; we
have one variant for each concrete implementation.</p>
<p>In this way, parametric polymorphism is dual to data abstraction.</p>
<p>Through the Curry-Howard isomorphism<a href="#fn2"
class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> a
generic <span class="math inline"><em>A</em></span> in our types
correspond to <span class="math inline">∀<em>A</em></span> in logic. In
other words, a universally quantified type variable in type theory is
isomorphic to a universally quantified propositional variable in logic.
The dual of <span class="math inline">∀</span> is <span
class="math inline">∃</span> or “there exists.” Now we can go backward
through Curry-Howard and land on the irrefutable conclusion that
<em>abstract types are existential types</em>. There exists some
concrete stack, where the implementor knows the underlying concrete
representation, but as the client, we don’t know the details. We
<em>existentially quantify</em> over the type of the concrete
representation.</p>
<h3 id="interface">Interface</h3>
<p>Our idealized form of data abstraction will refer to abstract data
types as <span class="math inline">∃<em>t</em>.<em>τ</em></span> where
<span class="math inline"><em>τ</em></span> stands in for some time that
depends on <span class="math inline"><em>t</em></span>. Concretely for
stacks: <span
class="math inline">∃<em>t</em>.⟨<em>c</em><em>r</em><em>e</em><em>a</em><em>t</em><em>e</em> : <em>i</em><em>n</em><em>t</em> → <em>t</em>, <em>p</em><em>u</em><em>s</em><em>h</em> : <em>t</em> → <em>i</em><em>n</em><em>t</em> → <em>t</em>, <em>p</em><em>o</em><em>p</em> : <em>t</em> → (<em>i</em><em>n</em><em>t</em>×<em>t</em>)⟩</span>.
In English, you may say, there exists some stack, <code>t</code>, with a
create function from <code>int</code> to <code>t</code>, a push function
from <code>t</code> and <code>int</code> to <code>t</code>, and a pop
function from <code>t</code> to <code>int</code> and <code>t</code>.</p>
<h3 id="implementation-1">Implementation</h3>
<p>We can pack a chosen representation type, <span
class="math inline"><em>ρ</em></span>, along with an implementation
<span class="math inline"><em>e</em></span> replacing <span
class="math inline"><em>ρ</em></span> for <span
class="math inline"><em>t</em></span> in our existential box to create
an abstract data type (or introducing a new variant to our infinite sum)
<span
class="math inline">⋃<em>ρ</em>; <em>e</em>; ∃<em>t</em>.<em>τ</em></span><a
href="#fn3" class="footnote-ref" id="fnref3"
role="doc-noteref"><sup>3</sup></a>. Concretely for the stack example we
can choose <span class="math inline"><em>ρ</em></span> to be the default
int and a list storing the values pushed so far: <span
class="math inline">⋃(<em>I</em><em>n</em><em>t</em>*<em>L</em><em>i</em><em>s</em><em>t</em>[<em>I</em><em>n</em><em>t</em>]); ⟨<em>c</em><em>r</em><em>e</em><em>a</em><em>t</em><em>e</em> = …, <em>p</em><em>u</em><em>s</em><em>h</em> = …, <em>p</em><em>o</em><em>p</em> = …⟩; ∃<em>t</em>.⟨<em>c</em><em>r</em><em>e</em><em>a</em><em>t</em><em>e</em> : <em>u</em><em>n</em><em>i</em><em>t</em> → <em>t</em>, <em>p</em><em>u</em><em>s</em><em>h</em> : <em>t</em> → <em>i</em><em>n</em><em>t</em> → <em>t</em>, <em>p</em><em>o</em><em>p</em> : <em>t</em> → (<em>i</em><em>n</em><em>t</em>×<em>t</em>)⟩</span></p>
<h3 id="client-1">Client</h3>
<p>A client is an expression that opens a packed value for use under an
environment where the choice of the existential <span
class="math inline"><em>t</em></span> is opaque. The client must be able
to run <em>for all</em> specific implementations. Due to these
requirements, it’s best to think of a client as a function<a href="#fn4"
class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> of
type <span
class="math inline">∀<em>t</em>.<em>τ</em> → <em>τ</em><sub>2</sub></span>.
Note, we add a further restriction that <span
class="math inline"><em>t</em></span> cannot show up in the return type
<span class="math inline"><em>τ</em><sub>2</sub></span>. We’ll show
below how this restriction increases the power of our abstract data
type. Concretely for the stack example: a function that pops two ints
off of our stack and returns their sum would have type <span
class="math inline">∀<em>t</em>.⟨<em>c</em><em>r</em><em>e</em><em>a</em><em>t</em><em>e</em> : <em>u</em><em>n</em><em>i</em><em>t</em> → <em>t</em>, <em>p</em><em>u</em><em>s</em><em>h</em> : <em>t</em> → <em>i</em><em>n</em><em>t</em> → <em>t</em>, <em>p</em><em>o</em><em>p</em> : <em>t</em> → (<em>i</em><em>n</em><em>t</em>×<em>t</em>)⟩ → <em>i</em><em>n</em><em>t</em></span></p>
<p>Recall that these idealized forms manifest themselves with a subset
of their power in our programming languages as shown below:</p>
<h2 id="properties-of-abstract-data-types">Properties of Abstract Data
Types</h2>
<p>In this section, we’ll enumerate a few interesting properties of
abstract data types first in their idealized forms and then in our
mainstream languages. If you only want to see languages that can
properly express all of these properties, skip to the OCaml or ReasonML
versions of these code samples.</p>
<h3 id="implementations-as-values">Implementations as values</h3>
<p>In an ideal world, a packed implementation is a value. It is
first-class. We can create it in an expression anonymously, we can
accept it as an argument to a function, and we can return it from a
function as well. <span
class="math inline">⋃<em>ρ</em>; <em>e</em>; ∃<em>t</em>.<em>τ</em></span>
can appear anywhere any other expression can appear.</p>
<p>Note: The seeming lack<a href="#fn5" class="footnote-ref" id="fnref5"
role="doc-noteref"><sup>5</sup></a> of power of Haskell is just due to
this section occurring before I explain Rank2 types.</p>
<p>This property provides many interesting capabilities that we won’t
enumerate in full. Here’s just one: Coupled with the rule restricting
the existentially quantified <span class="math inline"><em>t</em></span>
from appearing in the result of client functions, we can use the
first-classed-ness to allow for the unification of disparate concrete
types in branches as long as they pack to the same interface. Our
machines use dynamic dispatch to make this work at runtime.</p>
<p>Now, the rank2 <code>UI</code> type:</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">UI</span> a v <span class="ot">=</span> <span class="dt">UI</span> (<span class="kw">forall</span> component<span class="op">.</span> (<span class="dt">Reducer</span> a component <span class="ot">-&gt;</span> v))</span></code></pre></div>
<p>This type represents a UI at this moment. A <code>UI</code> is fed a
function for firing actions <code>a</code> to evolve the component and
in response returns some representation of a view.</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Component</span> w m v <span class="ot">=</span> <span class="dt">Component</span> (w (<span class="dt">UI</span> (m ()) v))</span></code></pre></div>
<p>Think of a component as a space of all possible future instantaneous
UIs with a pointer at the current one. You can avoid thinking about the
<code>w</code> in too much detail; just know that the <code>w</code>
defines the space of possible futures. <code>m</code> defines a way to
transition between the states.</p>
<!-- ![diagram showing the space of states normal, green, blank and a pointer to normal](/static/posts/data-abstraction/basic1.pdf.png) -->
<p>Notice that the <code>UI</code> doesn’t depend directly on
<code>Component</code> but does so indirectly through a rank2 type. When
these types are driven by the runtime, the quantified
<code>component</code> is replaced by the <code>Component</code> that
the <code>UI</code> was originally a part of. It is a corecursive
process that goes on forever — this is what we want as we don’t want our
UI to ever stop responding to actions.</p>
<p>The rank2 type here grants us the ability to not need to talk about
the <code>w</code> and <code>m</code> type parameters backing the
<code>Component</code> whenever we only want to concern ourselves with
the <code>UI</code>. We’ve simplified the interface for consumers of the
library.</p>
<p>I’ll explain these data types further as well as the comonadic UI
framework as a whole in later posts.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Data abstraction helps us work on large codebases with ourselves and
others by giving us tools to share and reuse code more easily. The Tower
of Taming Complexity argues we can clarify code with interfaces, clarify
interfaces with laws, and clarify lawful interfaces with algebraic
structures. The programming languages we use every day have a way to
express <em>interfaces</em>, <em>implementations</em>, and
<em>clients</em>, but rather than thinking about the theory of data
abstraction through our favorite language, we use an idealized one.
Idealized data abstraction, thinking about abstract data types as the
dual to parametric polymorphism, as existentials, shows us not only what
we can achieve in our existing languages today but what we hope to
achieve in future ones. Finally, we saw that existential types can be
expressed with rank2 universal types and dug a slightly deeper into the
comonadic UI framework.</p>
<p>Next time, we’ll cover the part of the tower on lawful interfaces.
We’ll dig into representation independence and discuss mechanically
discovering laws associated with interfaces. Plus how those laws guide
us towards nice property-based tests for our code. Thus, granting us the
courage within us to refactor without fear.</p>
<p>Thank you <a href="https://twitter.com/chriseidhof">Chris Eidhof</a>
and <a href="https://twitter.com/feministPLT">Daira Hopwood</a> for
pointing out some mistakes in early versions of this post! Thank you <a
href="https://twitter.com/SieraSolutions">Janne Siera</a> for adding F#
examples to the post!</p>
<h3 id="sources">Sources</h3>
<p>I heavily relied on Mitchell and Plotkin’s “Abstract Types Have
Existential Type” and Chapter 17 of Practical Foundations of Programming
Languages (PFPL) by Bob Harper, and, of course, Wikipedia when writing
this post. “Abstract Types Have Existential Type” more thoroughly talks
through the different forms of composition and power abstract types have
and PFPL introduces the existential, pack, and open syntactic forms,
shows typing rules and provides one take on the representability with
rank-2 types. I intended to repackage these pieces of information in a
simplified manner and reflecting on how this theory manifests within
mainstream programming languages. If you want to learn more, I recommend
reviewing these sources.</p>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>Pun intended.<a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>The Curry-Howard isomorphism allows us to teleport types
in our programming languages back and forth with theorems in logic;
values with proofs. This is a very fascinating property of our universe
and I encourage you to explore it! But that is not what this post is
about. To learn more see the <a
href="https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence">wikipedia
page</a> on the subject.<a href="#fnref2" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>For typesetting purposes, I chose a union symbol since
packing an implementation is like a variant constructor for the infinite
sum that the interface represents. In other literature, you may see this
represented with the operator “pack”.<a href="#fnref3"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>In order to simplify the presentation (and further
explanations below), I chose to think about clients as they’re expressed
in System-F. Typically, in other literature, you will see this
represented as “open” or “abstype”.<a href="#fnref4"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>I’m sure there’s some obscure extension that can support
first-class packed implementations, but I needed a transition to the
material later, so please let me tease it here.<a href="#fnref5"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>]]></content>
  </entry>
  <entry>
    <title>HELEEOOOSDF</title>
    <link href="https://ptrfrncsmrph.github.ioposts/sample-post-tooo.html"/>
    <id>https://ptrfrncsmrph.github.ioposts/sample-post-tooo.html</id>
    <updated>2019-01-01T00:00:00Z</updated>
    <category term="slick"/>
    <category term="site"/>
    <category term="data abstraction"/>
    <category term="haskell"/>
    <category term="typescript"/>
    <summary>My first blog post using slick</summary>
    <content type="html"><![CDATA[<h1 id="stateful-for-loops-in-rust-haskell">Stateful <code>for</code>
loops in Rust &amp; Haskell</h1>
<p><strong>Advent of Code spoilers herein</strong></p>
<p>Let’s look at some <code>for</code> loops, shall we?!</p>
<p>Day five of this year’s Advent of Code this year provides a nice
occasion for doing some stateful computation. We were given:</p>
<ul>
<li>an initial state of some stacks of crates</li>
<li>a list of instructions for moving crates from one stack to
another</li>
</ul>
<p>In Haskell I ended up using the <code>State</code> <del>monad</del>
applicative functor, and I am compelled to write down why, because it
was not that long ago that <code>State</code> was completely baffling to
me.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">State</span> s a <span class="ot">=</span> <span class="dt">State</span> {<span class="ot"> runState ::</span> s <span class="ot">-&gt;</span> (a, s) }</span></code></pre></div>
<p>How does this really model “state”?—how can we use this the same way
that we use a global mutable reference in imperative-style programming.
Let’s get some imports out of the way first.</p>
<multicodeblock-tabs>
<multicodeblock-tab role="heading" slot="tab">Haskell</multicodeblock-tab>
<multicodeblock-panel role="region" slot="panel">
<div class="sourceCode" id="cb2"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.State</span> (modify)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Foldable</span> (for_)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span></span></code></pre></div>
</multicodeblock-panel>
<multicodeblock-tab role="heading" slot="tab">Haskell</multicodeblock-tab>
<multicodeblock-panel role="region" slot="panel">
<div class="sourceCode" id="cb3"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- interface, abstract type: A typeclass</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">ExampleClass</span> a <span class="kw">where</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  create ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  read1 ::</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></span></code></pre></div>
</multicodeblock-panel>
<multicodeblock-tab role="heading" slot="tab">fsharp</multicodeblock-tab>
<multicodeblock-panel role="region" slot="panel">
<div class="sourceCode" id="cb4"><pre
class="sourceCode fsharp"><code class="sourceCode fsharp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> ExampleInterface&lt;&#39;a&gt; =</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">abstract</span> <span class="kw">member</span> create : <span class="dt">string</span> -&gt; &#39;a</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">abstract</span> <span class="kw">member</span> read   : &#39;a -&gt; <span class="dt">string</span></span></code></pre></div>
</multicodeblock-panel>

</multicodeblock-tabs>
<h3 id="implementation">Implementation</h3>
<multicodeblock-tabs>
<multicodeblock-tab role="heading" slot="tab">swift</multicodeblock-tab>
<multicodeblock-panel role="region" slot="panel">
<div class="sourceCode" id="cb5"><pre
class="sourceCode swift"><code class="sourceCode swift"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">// implementation: A struct (or a class)</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">struct</span> Example <span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="va">s</span><span class="op">:</span> string</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">public</span> <span class="kw">static</span> <span class="kw">func</span> <span class="fu">create</span><span class="op">(</span><span class="va">_</span> <span class="va">s</span><span class="op">:</span> <span class="dt">string</span><span class="op">)</span> -&gt; <span class="fu">Example</span> <span class="op">{</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> Example<span class="op">(</span>s<span class="op">:</span> s<span class="op">)</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">public</span> <span class="kw">func</span> <span class="fu">read</span><span class="op">()</span> -&gt; <span class="fu">String</span> <span class="op">{</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="kw">self</span><span class="op">.</span>s</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</multicodeblock-panel>
<multicodeblock-tab role="heading" slot="tab">TypeScript</multicodeblock-tab>
<multicodeblock-panel role="region" slot="panel">
<div class="sourceCode" id="cb6"><pre
class="sourceCode typescript"><code class="sourceCode typescript"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">// implementation: A function (for static members)</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="co">//                 A class (for instance ones)</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">createExample</span>(ctor<span class="op">:</span> ExampleConstructor<span class="op">,</span> s<span class="op">:</span> <span class="dt">string</span>)<span class="op">:</span> ExampleInterface {</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="kw">new</span> <span class="fu">ctor</span>(s)<span class="op">;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Example <span class="kw">implements</span> ExampleInterface {</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>  s<span class="op">:</span> <span class="dt">string</span><span class="op">;</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">constructor</span>(s<span class="op">:</span> <span class="dt">string</span>) {</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">s</span> <span class="op">=</span> s<span class="op">;</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">read</span>()<span class="op">:</span> <span class="dt">string</span> {</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">this</span><span class="op">.</span><span class="at">s</span><span class="op">;</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
</multicodeblock-panel>
<multicodeblock-tab role="heading" slot="tab">Haskell</multicodeblock-tab>
<multicodeblock-panel role="region" slot="panel">
<div class="sourceCode" id="cb7"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- implementation: A typeclass instance</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ExampleClass</span> <span class="dt">String</span> <span class="kw">where</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  create <span class="ot">=</span> <span class="fu">id</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  read1 <span class="ot">=</span> <span class="fu">id</span></span></code></pre></div>
</multicodeblock-panel>
<multicodeblock-tab role="heading" slot="tab">fsharp</multicodeblock-tab>
<multicodeblock-panel role="region" slot="panel">
<div class="sourceCode" id="cb8"><pre
class="sourceCode fsharp"><code class="sourceCode fsharp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> Example <span class="op">()</span> =</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    interface ExampleInterface&lt;<span class="dt">string</span>&gt; <span class="kw">with</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">member</span> _.create s = s</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">member</span> _.read s = s</span></code></pre></div>
</multicodeblock-panel>

</multicodeblock-tabs>
<h3 id="client">Client</h3>
<multicodeblock-tabs>
<multicodeblock-tab role="heading" slot="tab">swift</multicodeblock-tab>
<multicodeblock-panel role="region" slot="panel">
<div class="sourceCode" id="cb9"><pre
class="sourceCode swift"><code class="sourceCode swift"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="fu">client</span><span class="op">&lt;</span><span class="dt">E</span><span class="op">:</span> <span class="dt">ExampleInterface</span><span class="op">&gt;()</span> <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="va">ex</span> <span class="op">=</span> E<span class="op">.</span>create<span class="op">(</span><span class="st">&quot;hello&quot;</span><span class="op">);</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  println<span class="op">(</span>ex<span class="op">.</span>read<span class="op">());</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</multicodeblock-panel>
<multicodeblock-tab role="heading" slot="tab">TypeScript</multicodeblock-tab>
<multicodeblock-panel role="region" slot="panel">
<div class="sourceCode" id="cb10"><pre
class="sourceCode typescript"><code class="sourceCode typescript"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co">// client</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="co">// it&#39;s a bit hard to write down a generic function for this in TypeScript</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="co">// because there are two separate interfaces</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> ex <span class="op">=</span> <span class="fu">createExample</span>(Example<span class="op">,</span> <span class="st">&quot;hello&quot;</span>)<span class="op">;</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(ex<span class="op">.</span><span class="fu">read</span>())<span class="op">;</span></span></code></pre></div>
</multicodeblock-panel>
<multicodeblock-tab role="heading" slot="tab">ocaml</multicodeblock-tab>
<multicodeblock-panel role="region" slot="panel">
<div class="sourceCode" id="cb11"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* a client is a functor *)</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> Client(E: Example_intf) = <span class="kw">struct</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> ex = E.create <span class="st">&quot;hello&quot;</span> <span class="kw">in</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  printf <span class="st">&quot;%s</span><span class="ch">\n</span><span class="st">&quot;</span> (E.read ex)</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="co">(* we can make clients first-class with first-class modules *)</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> client (<span class="kw">module</span> E: Example_intf) =</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> ex = E.create <span class="st">&quot;hello&quot;</span> <span class="kw">in</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>  printf <span class="st">&quot;%s</span><span class="ch">\n</span><span class="st">&quot;</span> (E.read ex)</span></code></pre></div>
</multicodeblock-panel>
<multicodeblock-tab role="heading" slot="tab">Rust</multicodeblock-tab>
<multicodeblock-panel role="region" slot="panel">
<div class="sourceCode" id="cb12"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> client<span class="op">&lt;</span>E<span class="op">:</span> Example<span class="op">&gt;</span>() <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> ex <span class="op">=</span> <span class="pp">E::</span>create()<span class="op">;</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  <span class="pp">println!</span>(<span class="st">&quot;{:}&quot;</span><span class="op">,</span> ex<span class="op">.</span>read())<span class="op">;</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</multicodeblock-panel>
<multicodeblock-tab role="heading" slot="tab">Haskell</multicodeblock-tab>
<multicodeblock-panel role="region" slot="panel">
<div class="sourceCode" id="cb13"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ot">client ::</span> <span class="dt">ExampleClass</span> e <span class="ot">=&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>client <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> ex <span class="ot">=</span> create <span class="st">&quot;hello&quot;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> read1 ex</span></code></pre></div>
</multicodeblock-panel>
<multicodeblock-tab role="heading" slot="tab">fsharp</multicodeblock-tab>
<multicodeblock-panel role="region" slot="panel">
<div class="sourceCode" id="cb14"><pre
class="sourceCode fsharp"><code class="sourceCode fsharp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> E = Example <span class="op">()</span> :&gt; ExampleInterface&lt;<span class="dt">string</span>&gt;</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> ex = E<span class="kw">.</span>create <span class="st">&quot;hello&quot;</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>E<span class="kw">.</span>read ex |&gt; printf <span class="st">&quot;%s</span><span class="sc">\n</span><span class="st">&quot;</span></span></code></pre></div>
</multicodeblock-panel>

</multicodeblock-tabs>
<p>The surface syntax differs among programming languages, but through
them all, you can identify a <em>client</em> interacting with an
<em>implementation</em> through an <em>interface</em>. The extent to
which they achieve the ideal, from a semantics perspective, is something
we will study in this post. Studying the ideal equips the student with
the capacity for applying these techniques across all programming
languages rather than relearning what is truly the same each time a new
language is presented.</p>
<p>To <em>really</em> understand what an interface does it must be
equipped with laws. With sufficient laws, concrete implementations can
be swapped without clients observing changes, or dually, clients can be
written without implementations existing. “Sufficient laws” gives us
both obvious property-based tests and a state known as
<em>representation independence</em>, but this we will discuss in
another post.</p>]]></content>
  </entry>
  <entry>
    <title>Great Post</title>
    <link href="https://ptrfrncsmrph.github.ioposts/sample-post.html"/>
    <id>https://ptrfrncsmrph.github.ioposts/sample-post.html</id>
    <updated>2019-01-01T00:00:00Z</updated>
    <category term="slick"/>
    <category term="site"/>
    <summary>My first blog post using slick</summary>
    <content type="html"><![CDATA[<p>It’s nice.</p>
<p>
This should be a paragraph
</p>
<p><span>This is a span</span></p>
<h3>
What happens here?
</h3>
  <custom-element>
    <another-el>
<div class="sourceCode" id="cb1"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="st">&quot;does this work?&quot;</span></span></code></pre></div>
    </another-el>
  </custom-element>
<multicodeblock-tabs>
  <multicodeblock-tab role="heading" slot="tab">Haskell</multicodeblock-tab>
  <multicodeblock-panel role="region" slot="panel">
<div class="sourceCode" id="cb2"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="st">&quot;So doppppppeeee1!!!!&quot;</span></span></code></pre></div>
  </multicodeblock-panel>
  <multicodeblock-tab role="heading" slot="tab">TypeScript</multicodeblock-tab>
  <multicodeblock-panel role="region" slot="panel">
<div class="sourceCode" id="cb3"><pre
class="sourceCode typescript"><code class="sourceCode typescript"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> main <span class="op">=</span> () <span class="kw">=&gt;</span> {</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&quot;Soo dooopppppe!!!!&quot;</span>)<span class="op">;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>}<span class="op">;</span></span></code></pre></div>
  </multicodeblock-panel>
</multicodeblock-tabs>]]></content>
  </entry>
</feed>
